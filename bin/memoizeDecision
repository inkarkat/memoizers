#!/bin/bash
shopt -qs extglob

: ${MEMOIZEDECISION_QUERY_PREFIX=[01m}
: ${MEMOIZEDECISION_QUERY_SUFFIX=[0m}
: ${MEMOIZEDECISION_POSITIVE_OPTION_PREFIX=[34m}
: ${MEMOIZEDECISION_POSITIVE_OPTION_SUFFIX=[0m}
: ${MEMOIZEDECISION_NEGATIVE_OPTION_PREFIX=[31m}
: ${MEMOIZEDECISION_NEGATIVE_OPTION_SUFFIX=[0m}
: ${MEMOIZEDECISION_POSITIVE_OPTION_GROUP_PREFIX=[04m}
: ${MEMOIZEDECISION_POSITIVE_OPTION_GROUP_SUFFIX=[0;34m}
: ${MEMOIZEDECISION_NEGATIVE_OPTION_GROUP_PREFIX=[04m}
: ${MEMOIZEDECISION_NEGATIVE_OPTION_GROUP_SUFFIX=[0;31m}
: ${MEMOIZEDECISION_HELP_GROUP_PREFIX=[04m}
: ${MEMOIZEDECISION_HELP_GROUP_SUFFIX=[0m}
: ${MEMOIZEDECISION_OPTION_ACCELERATOR_PREFIX=[[01m}
: ${MEMOIZEDECISION_OPTION_ACCELERATOR_SUFFIX=[0m]}
: ${MEMOIZEDECISION_POSITIVE_OPTION_ACCELERATOR_PREFIX=[[01;34m}
: ${MEMOIZEDECISION_POSITIVE_OPTION_ACCELERATOR_SUFFIX=[0;34m]}
: ${MEMOIZEDECISION_NEGATIVE_OPTION_ACCELERATOR_PREFIX=[[01;31m}
: ${MEMOIZEDECISION_NEGATIVE_OPTION_ACCELERATOR_SUFFIX=[0;31m]}
: ${MEMOIZEDECISION_POSITIVE_PREFIX=[32m}
: ${MEMOIZEDECISION_POSITIVE_SUFFIX=[0m}
: ${MEMOIZEDECISION_NEGATIVE_PREFIX=[33m}
: ${MEMOIZEDECISION_NEGATIVE_SUFFIX=[0m}
: ${MEMOIZEDECISION_VALID_TIMESPAN_SECONDS:=900}

timeToSeconds()
{
    case "$1" in
	+([0-9])?(s))   time="${1%s}";;
	+([0-9])m)	time=$((${1%m} * 60));;
	+([0-9])h)	time=$((${1%h} * 3600));;
	+([0-9])d)	time=$((${1%d} * 86400));;
	*)		printf >&2 "ERROR: Illegal ${2:-timeout}: %s\\n" "$1"; exit 2;;
    esac
    printf %s "$time"
}
printShortUsage()
{
    # Note: short followed by long option; if the user knows the short one, she can
    # skim the long one.
printf 'Usage: %q %s\n' "$(basename "$1")" '-g|--memoize-group GROUP -s|--subject SUBJECT [--verb VERB] -t|--state STATE -a|--action ACTION [--timespan TIMESPAN[SUFFIX]] [--timeout TIMEOUT[SUFFIX]] [-d|--default c|y|a|l|A|d|n|o|v|N] [-?|-h|--help]'
printf 'Usage: %q %s\n' "$(basename "$1")" '-g|--memoize-group GROUP -s|--subject SUBJECT -c|--set-decision y|a|l|A|n|o|v|N [-a|--action ACTION] [--timespan TIMESPAN[SUFFIX]]'
}
printUsage()
{
    # This is the short help when launched with no or incorrect arguments.
    # It is printed to stderr to avoid accidental processing.
    printShortUsage "$1" >&2
    printf >&2 'Try %q --help for more information.\n' "$(basename "$1")"
}
printLongUsage()
{
    # This is the long "man page" when launched with the help argument.
    # It is printed to stdout to allow paging with 'more'.
    cat <<HELPDESCRIPTION
Query the user whether ACTION should be performed on SUBJECT to turn it into
STATE, and remember the decision.
HELPDESCRIPTION
    echo
    printShortUsage "$1"
    cat <<HELPTEXT
If later (depending on the decision "soon" (within 15 minutes), or at any time)
again called (with the same GROUP, depending on the decision for the same
SUBJECT, or any), the decision is recalled and the user is not queried again.
Question to the user is
    SUBJECT ([VERB] / does not) STATE. Shall I / Will now / Do not ACTION?
For automation / testing, the query can be pre-answered by defining
MEMOIZEDECISION_CHOICE.
    --memoize-group|-g GROUP	Category in the context of the subject.
    --subject|-s SUBJECT	The subject on which ACTION is performed.
    --verb VERB			The negation of what the desired STATE is.
    --state|-t STATE		The desired, positive end state after performing
				ACTION.
    --action|-a ACTION		What gets executed if the user answers
				positively.
    --timespan TIMESPAN[SUFFIX]	Recall a previous answer given for that GROUP
				and SUBJECT if a previous invocation (with an
				answer of yes/any/no/none) had happened within
				TIMESPAN (default ${MEMOIZEDECISION_VALID_TIMESPAN_SECONDS} seconds).
				SUFFIX may be 's' for seconds (the default), 'm'
				for minutes, 'h' for hours or 'd' for days.
    --timeout TIMEOUT[SUFFIX]	Do not wait indefinitely for the user's answer,
				but abort / use the --default instead after
				TIMEOUT have passed without an answer.
    --default|-d confirm-each|c|yes|y|any|a|always|l|any-always|A|decline-each|d|no|n|none|o|never|v|none-never|N
				Use the provided answer if querying is not
				possible (no terminal) or when the user fails to
				answer within the provided --timeout.
    --set-decision|-c yes|y|any|a|always|l|any-always|A|no|n|none|o|never|v|none-never|N
				Instead of querying, use the passed decision as
				if the user had chosen it (for --timespan
				TIMEOUT for y|a|n|o). If ACTION is passed, a
				corresponding information message is printed;
				without it, the decision is consumed silently.

EXIT STATUS:
    0 if ACTION should be performed
    1 if not
    2 on invocation error
    3 if memoization fails or the query times out without a given --default
HELPTEXT
}
assertValidChoice()
{
    case "$1" in
	confirm-each|c|yes|y|any|a|always|l|any-always|A|decline-each|d|no|n|none|o|never|v|none-never|N)
	    return 0;;
	*)  return 1;;
    esac
}

group=
subject=
verb='does not'
state=
action=
default=
decision=
timeout=
typeset -a readArgs=()
while [ $# -ne 0 ]
do
    case "$1" in
	--help|-h|-\?)	shift; printLongUsage "$0"; exit 0;;
	--memoize-group|-g)	shift; group="$1"; shift;;
	--subject|-s)		shift; subject="$1"; shift;;
	--verb)			shift; verb="$1"; shift;;
	--state|-t)		shift; state="$1"; shift;;
	--action|-a)		shift; action="$1"; shift;;
	--timespan)		shift; MEMOIZEDECISION_VALID_TIMESPAN_SECONDS="$(timeToSeconds "$1" timespan)" || exit $?; shift;;
	--timeout)	shift; timeInSeconds="$(timeToSeconds "$1" timeout)" || exit $?; shift
			timeoutPlural=s; [ "$timeInSeconds" = 1 ] && timeoutPlural=; timeout="Within $timeInSeconds second${timeoutPlural}: "; readArgs+=(-t "$timeInSeconds")
			;;
	--default|-d)	shift; if assertValidChoice "$1"; then
			    default="$1"
			else
			    printf >&2 'ERROR: Invalid default: %s\n' "$1"
			    exit 2
			fi
			shift
			;;
	--set-decision|-c)
			shift
			case "$1" in
			    yes|y|any|a|always|l|any-always|A|no|n|none|o|never|v|none-never|N)
				decision=$1;;
			    *)	printf >&2 'ERROR: Invalid decision: %s\n' "$1"; exit 2;;
			esac
			shift
			;;
	--)		shift; break;;
	-*)		{ echo "ERROR: Unknown option \"$1\"!"; echo; printShortUsage "$0"; } >&2; exit 2;;
	*)		break;;
    esac
done
if [ $# -gt 0 -o ! "$group" -o ! "$subject" -o \( -z "$decision" -a \( ! "$state" -o ! "$action" \) \) ]; then
    printUsage "$0"
    exit 2
fi

marker()
{
    executionMarker --namespace memoizeDecision --group "$group" --fallback-subject '*' "$@"
}

writeMarker()
{
    local subject=${1:?}; shift
    local exitStatus=${1:?}; shift

    typeset -a foreverArgs=()
    local isForever=$1; shift
    [ "$isForever" ] && foreverArgs=(--timestamp 4294967295)

    marker --update "$subject" --context "$exitStatus" "${foreverArgs[@]}" || exit 3
    return $exitStatus
}

hasMarker()
{
    local subject=${1:?}; shift
    markerExitStatus="$(marker --query "$subject" --within "$MEMOIZEDECISION_VALID_TIMESPAN_SECONDS" --get-context)" || return $?
}

getTimespanDuration()
{
    reldate --timespan "$MEMOIZEDECISION_VALID_TIMESPAN_SECONDS" 2>/dev/null || printf '%d seconds' "$MEMOIZEDECISION_VALID_TIMESPAN_SECONDS"
}
processChoice()
{
    case "${1:?}" in
	h)
	    timespanDuration="$(getTimespanDuration)"

	    pos=$MEMOIZEDECISION_POSITIVE_OPTION_PREFIX
	    poe=$MEMOIZEDECISION_POSITIVE_OPTION_SUFFIX
	    nos=$MEMOIZEDECISION_NEGATIVE_OPTION_PREFIX
	    noe=$MEMOIZEDECISION_NEGATIVE_OPTION_SUFFIX
	    p=$MEMOIZEDECISION_OPTION_ACCELERATOR_PREFIX
	    q=$MEMOIZEDECISION_OPTION_ACCELERATOR_SUFFIX
	    pp=$MEMOIZEDECISION_POSITIVE_OPTION_ACCELERATOR_PREFIX
	    pq=$MEMOIZEDECISION_POSITIVE_OPTION_ACCELERATOR_SUFFIX
	    np=$MEMOIZEDECISION_NEGATIVE_OPTION_ACCELERATOR_PREFIX
	    nq=$MEMOIZEDECISION_NEGATIVE_OPTION_ACCELERATOR_SUFFIX
	    gp="${MEMOIZEDECISION_POSITIVE_OPTION_GROUP_PREFIX}${group}${MEMOIZEDECISION_POSITIVE_OPTION_GROUP_SUFFIX}"
	    gn="${MEMOIZEDECISION_NEGATIVE_OPTION_GROUP_PREFIX}${group}${MEMOIZEDECISION_NEGATIVE_OPTION_GROUP_SUFFIX}"
	    cat <<EOF
${pos}${pp}c${pq}onfirm each${poe}: Accept once; continue asking for this particular $subject, even
		if it occurs again soon.
${pos}${pp}y${pq}es${poe}         : Only this particular $subject, now and for $timespanDuration.
${pos}${pp}a${pq}ny${poe}         : Every subject in $pg (not just $subject),
		now and for $timespanDuration.
${pos}a${pp}l${pq}ways${poe}      : This particular $subject, now and in eternity.
${pos}${pp}A${pq}ny always${poe}  : Every subject in $pg, now and in eternity.

${nos}${np}d${nq}ecline each${noe}: Not this one, and continue asking for this particular $subject,
		even if it occurs again soon.
${nos}${np}n${nq}o${noe}          : Not this particular $subject, not now and not for $timespanDuration.
${nos}n${np}o${nq}ne${noe}        : No subject in $ng (not just $subject),
		not now and not for $timespanDuration.
${nos}ne${np}v${nq}er${noe}       : Not this particular $subject, not now and also never in
		eternity.
${nos}${np}N${nq}one never${noe}  : No subject in $ng, not now and also never in eternity.

EOF
	    ;;
	c|confirm-each)	    return 0;;
	y|yes)		    writeMarker "$subject" 0 '';;
	a|any)		    writeMarker '*'	   0 '';;
	l|always)	    writeMarker "$subject" 0 t;;
	A|any-always)	    writeMarker '*'	   0 t;;
	d|decline-each)	    return 1;;
	q)		    return 1;;
	n|no)		    writeMarker "$subject" 1 '';;
	o|none)		    writeMarker '*'	   1 '';;
	v|never)	    writeMarker "$subject" 1 t;;
	N|none-never)	    writeMarker '*'	   1 t;;
    esac
}

if [ "$decision" ]; then
    processChoice "$decision"

    [ "$action" ] && case "$decision" in
	y|yes)		    printf >&2 'For this particular %s, will %s for the next %s.\n' "$subject" "$action" "$(getTimespanDuration)";;
	a|any)		    printf >&2 'For every subject in %s, will %s for the next %s.\n' "$group" "$action" "$(getTimespanDuration)";;
	l|always)	    printf >&2 'For this particular %s, will %s for eternity.\n' "$subject" "$action";;
	A|any-always)	    printf >&2 'For every subject in %s, will %s for eternity.\n' "$group" "$action";;
	n|no)		    printf >&2 'For this particular %s, will not %s for the next %s.\n' "$subject" "$action" "$(getTimespanDuration)";;
	o|none)		    printf >&2 'For every subject in %s, will not %s for the next %s.\n' "$group" "$action" "$(getTimespanDuration)";;
	v|never)	    printf >&2 'For this particular %s, will not %s for eternity.\n' "$subject" "$action";;
	N|none-never)	    printf >&2 'For every subject in %s, will not %s for eternity.\n' "$group" "$action";;
    esac

    exit 0
fi


while :
do
    if hasMarker "$subject"; then
	if [ $markerExitStatus -eq 0 ]; then
	    printf >&2 '%s%s %s %s. Will %s now.%s\n' "$MEMOIZEDECISION_POSITIVE_PREFIX" "$subject" "$verb" "$state" "$action" "$MEMOIZEDECISION_POSITIVE_SUFFIX"
	else
	    printf >&2 '%s%s %s %s. Do not %s.%s\n' "$MEMOIZEDECISION_NEGATIVE_PREFIX" "$subject" "$verb" "$state" "$action" "$MEMOIZEDECISION_NEGATIVE_SUFFIX"
	fi
	exit $markerExitStatus
    else
	# Force reading directly from terminal / null device if stdin is redirected,
	# to avoid consuming input.
	if [ "$MEMOIZEDECISION_CHOICE" ] || { exec 0</dev/tty; } 2>/dev/null; then
	    printf -v query '%s%s %s %s. Shall I %s?%s' "$MEMOIZEDECISION_QUERY_PREFIX" "$subject" "$verb" "$state" "$action" "$MEMOIZEDECISION_QUERY_SUFFIX"
	    p=$MEMOIZEDECISION_OPTION_ACCELERATOR_PREFIX
	    q=$MEMOIZEDECISION_OPTION_ACCELERATOR_SUFFIX
	    pp=$MEMOIZEDECISION_POSITIVE_OPTION_ACCELERATOR_PREFIX
	    pq=$MEMOIZEDECISION_POSITIVE_OPTION_ACCELERATOR_SUFFIX
	    np=$MEMOIZEDECISION_NEGATIVE_OPTION_ACCELERATOR_PREFIX
	    nq=$MEMOIZEDECISION_NEGATIVE_OPTION_ACCELERATOR_SUFFIX
	    gp="${MEMOIZEDECISION_POSITIVE_OPTION_GROUP_PREFIX}${group}${MEMOIZEDECISION_POSITIVE_OPTION_GROUP_SUFFIX}"
	    gn="${MEMOIZEDECISION_NEGATIVE_OPTION_GROUP_PREFIX}${group}${MEMOIZEDECISION_NEGATIVE_OPTION_GROUP_SUFFIX}"
	    printf -v options "(%s%s${pp}c${pq}onfirm each / ${pp}y${pq}es / ${pp}a${pq}ny %s / a${pp}l${pq}ways / ${pp}A${pq}ny %s always%s / %s${np}d${nq}ecline each = ${np}q${nq}uit / ${np}n${nq}o / n${np}o${nq}ne from %s / ne${np}v${nq}er / ${np}N${nq}one from %s never%s / ${p}h${q}elp)" \
		"$MEMOIZEDECISION_POSITIVE_OPTION_PREFIX" "$timeout" "$gp" "$gp" "$MEMOIZEDECISION_POSITIVE_OPTION_SUFFIX" "$MEMOIZEDECISION_NEGATIVE_OPTION_PREFIX" "$gn" "$gn" "$MEMOIZEDECISION_NEGATIVE_OPTION_SUFFIX"
	    if [ "$MEMOIZEDECISION_CHOICE" ]; then
		CHOICE="$MEMOIZEDECISION_CHOICE"
		printf >&2 '%s%s\n' "$query $options " "$CHOICE"
		status=0
	    else
		CHOICE="$(userquery "${readArgs[@]}" -n 1 -p "$query $options ")"
		status=$?
		echo >&2
	    fi
	else
	    # When we cannot read from the terminal ("/dev/tty: No such device or address"), use default or abort.
	    status=129
	fi

	if [ $status -gt 128 ]; then
	    if [ "$default" ]; then
		CHOICE=$default
	    else
		exit 3
	    fi
	elif [ $status -ne 0 ]; then
	    exit 3
	fi
    fi

    processChoice "$CHOICE"
    status=$?
    [ "$CHOICE" = 'h' ] && continue
    exit $status
done
