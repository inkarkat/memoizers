#!/bin/bash

printUsage()
{
    cat <<HELPTEXT
Query the user whether ACTION should be performed on SUBJECT to turn it into
STATE, and remember the decision. If later (depending on the decision "soon"
(within 15 minutes), or at any time) again called (with the same GROUP,
depending on the decision for the same SUBJECT, or any), the decision is
recalled and the user is not queried again.
Question to the user is
    SUBJECT ([VERB] / does not) STATE. Shall I / Will now / Do not ACTION?
Returns 0 if ACTION should be performed, 1 if not, 2 on invocation error; 3 if
memoization fails or the query times out without a given --default.
HELPTEXT
printf 'Usage: %q %s\n' "$(basename "$1")" '-g|--memoize-group GROUP -s|--subject SUBJECT [--verb VERB] -t|--state STATE -a|--action ACTION [--timespan SECONDS] [--timeout SECONDS] [-d|--default c|y|a|l|A|d|n|o|v|N] [-?|-h|--help]'
}

group=
subject=
verb='does not'
state=
action=
markerValidTimespanInSeconds=900
default=
timeout=
typeset -a readArgs=()
while [ $# -ne 0 ]
do
    case "$1" in
	--memoize-group|-g)	shift; group="$1"; shift;;
	--subject|-s)		shift; subject="$1"; shift;;
	--verb)			shift; verb="$1"; shift;;
	--state|-t)		shift; state="$1"; shift;;
	--action|-a)		shift; action="$1"; shift;;
	--timespan)		shift; markerValidTimespanInSeconds="$1"; shift;;
	--timeout)	shift; timeoutPlural=s; [ "$1" = 1 ] && timeoutPlural=; timeout="Within $1 second${timeoutPlural}: "; readArgs+=(-t "$1"); shift;;
	--default|-d)	shift
			case "$1" in
			    c|y|a|l|A|d|n|o|v|N)  default=$1;;
			    *)	    printf >&2 'ERROR: Invalid default: %s\n' "$1"; exit 2;;
			esac
			shift
			;;
	--help|-h|-\?)	shift; printUsage "$0"; exit 0;;
	--)		shift; break;;
	-*)		{ echo "ERROR: Unknown option \"$1\"!"; echo; printUsage "$0"; } >&2; exit 2;;
	*)		break;;
    esac
done
if [ $# -gt 0 -o ! "$group" -o ! "$subject" -o ! "$state" -o ! "$action" ]; then
    printUsage "$0"
    exit 2
fi

readonly CONFIG_DIRSPEC=${XDG_CONFIG_HOME:-~/.config}/memoizeDecision
[ -d "$CONFIG_DIRSPEC" ] || mkdir -p -- "$CONFIG_DIRSPEC" || { printf >&2 'ERROR: Could not initialize configuration store at %s!\n' "$CONFIG_DIRSPEC"; exit 3; }
readonly MARKER_FILESPEC="${CONFIG_DIRSPEC}/$group"

writeMarker()
{
    local subject=${1:?}; shift
    local literalSubjectPattern=$(printf %s "$subject" | sed -e 's/[][\$*.^/]/\\&/g')
    local exitStatus=${1:?}; shift
    local isForever=$1; shift
    local timestamp=4294967295; [ "$isForever" ] || timestamp=$(date +%s)

    [ -r "$MARKER_FILESPEC" ] || printf '# SUBJECT\tEXIT STATUS\tTIME STAMP\n' > "$MARKER_FILESPEC"  # Need to write at least one line so that sed does processing; can use that for a descriptive header.
    sed -i -e "/^${literalSubjectPattern}\\t/d" -e "\$a${subject}	${exitStatus}	${timestamp}" "$MARKER_FILESPEC" || exit 3
    exit $exitStatus
}

hasMarker()
{
    [ -e "$MARKER_FILESPEC" ] || return 1

    local subject=${1:?}; shift
    local literalSubjectPattern=$(printf %s "$subject" | sed -e 's/[][\$*.^/]/\\&/g')

    # Get the $subject line, with fallback to "*".
    local line=$(sed -n -e "/^${literalSubjectPattern}\\t\\|^\\*\\t/H" -e '${ g; s/^\n//; s/^\*\t.*\n//; s/\n\*\t.*$//; /./p }' "$MARKER_FILESPEC")
    [ "$line" ] || return 1

    IFS=$'\t' read -r readSubject markerExitStatus markerTimestamp <<< "$line"

    local now=$(date +%s)
    [ $markerTimestamp -ge $((now - markerValidTimespanInSeconds)) ]	# Marker is valid for a brief timespan.
}


while :
do
    if hasMarker "$subject"; then
	if [ $markerExitStatus -eq 0 ]; then
	    printf '%s %s %s. Will %s now.\n' "$subject" "$verb" "$state" "$action"
	else
	    printf '%s %s %s. Do not %s.\n' "$subject" "$verb" "$state" "$action"
	fi
	exit $markerExitStatus
    else
	printf -v query "$subject $verb $state. Shall I ${action}?"
	< /dev/tty read "${readArgs[@]}" -n 1 -p "$query (${timeout}[c]onfirm each / [y]es / [a]ny $group / a[l]ways / [A]ny $group always / [d]ecline each / [n]o / n[o]ne from $group / ne[v]er / [N]one from $group never / [h]elp) " CHOICE
	status=$?
	echo

	if [ $status -gt 128 ]; then
	    if [ "$default" ]; then
		CHOICE=$default
	    else
		exit 3
	    fi
	fi
    fi

    case "$CHOICE" in
	h)
	    timespanDuration=$(reldate --timespan "$markerValidTimespanInSeconds" 2>/dev/null || printf '%d seconds' "$markerValidTimespanInSeconds")

	    cat <<EOF
[c]onfirm each: Accept once; continue asking for this particular $subject, even
                if it occurs again soon.
[y]es         : Only this particular $subject, now and for $timespanDuration.
[a]ny         : Every subject in $group (not just $subject), now and for $timespanDuration.
a[l]ways      : This particular $subject, now and in eternity.
[A]ny always  : Every subject in $group, now and in eternity.

[d]ecline each: Not this one, and continue asking for this particular $subject,
                even if it occurs again soon.
[n]o          : Not this particular $subject, not now and not for $timespanDuration.
n[o]ne        : No subject in $group (not just $subject), not now and not for $timespanDuration.
ne[v]er       : Not this particular $subject, not now and also never in
		eternity.
[N]one never  : No subject in $group, not now and also never in eternity.

EOF
	    ;;
	c)  exit 0;;
	y)  writeMarker "$subject" 0 '';;
	a)  writeMarker '*'	   0 '';;
	l)  writeMarker "$subject" 0 t;;
	A)  writeMarker '*'	   0 t;;
	d)  exit 1;;
	n)  writeMarker "$subject" 1 '';;
	o)  writeMarker '*'	   1 '';;
	v)  writeMarker "$subject" 1 t;;
	N)  writeMarker '*'	   1 t;;
    esac
done
